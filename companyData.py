# coding:utf-8import pandas as pdimport numpy as npimport osimport openpyxlfrom datetime import datetime,date,timedeltaimport matplotlib.pyplot as pltimport seaborn as sns#自定义printdef printInfo(str,obj):    print ('\n'+'-'*15+str+'-'*15+'\n')    print (obj)#初始化处理数据def initData(date_str):    PROJECT_ROOT = os.path.dirname(os.path.realpath(__file__))    path = os.path.join(PROJECT_ROOT, 'data/企业报名转化_' + date_str + '.xlsx')    df = pd.read_excel(path)    # 去掉第一行的数字columns    df = df.rename(columns=df.loc[0])    # 删除多余的第一行数据    df.drop(labels=0, axis=0, inplace=True)    # 重新排序设置index    df = df.reset_index(drop=True)    printInfo('显示数据源head10',df.head(10))    printInfo('元数据shape',df.shape)    print(df.info())    #删除数据中已申请公司=无    df = df[df['已申请的公司'] != '无']    # 获取公司名称为Nan的数据的index    index = df[df['已申请的公司'].isnull().values == True].index    # 删除对应公司数据    df = df.drop(index)    #找出其中混沌大学重复数量多，而且每个重复都有对应人数，所以将其公司名称拼接上申请人，作为独立公司来看    temp_df = df[df['已申请的公司'].str.startswith('混沌大学')]    temp_df['已申请的公司'] = temp_df['已申请的公司'] + '_' + df['申请人']    df[df['已申请的公司'].str.startswith('混沌大学')] = temp_df    # 按照申请公司和领取用户数倒叙排列，然后删除重复项，保留第一个，等同于保留最大值    df = df.sort_values(by=['已申请的公司', '领取用户数'], ascending=False).drop_duplicates(subset='已申请的公司', keep='first',                                                                                      inplace=False).reset_index(        drop=True)    printInfo('排序之后去重数据', df)    printInfo('排序去重后领课用户数和观看课程用户数', df[['领取用户数', '观看课程用户数']].sum())    #将对应数据转化为数值型    df['领取用户数'] = df['领取用户数'].astype(int)    df['观看课程用户数'] = df['观看课程用户数'].astype(int)    df['观看转化率'] = df['观看转化率'].astype(float)    df['平均学习时长（秒）'] = df['平均学习时长（秒）'].astype(float)    return df#赋值函数def set_course_count_value(result_df,data,index,top_number):    result_df.loc[index,'领取用户数'] = data['领取用户数'][0:top_number].sum()    result_df.loc[index,'观看课程用户数'] = data['观看课程用户数'][0:top_number].sum()    result_df.loc[index,'领取占比整体'] = data['领取用户数'][0:top_number].sum() / data['领取用户数'].sum()    result_df.loc[index,'观看占比整体'] = data['观看课程用户数'][0:top_number].sum() / data['观看课程用户数'].sum()    return result_df#头部TOP10企业领取，看课数量，占比整体百分比，分社归属分布def get_course_count(df):    data = df[['归属分社','已申请的公司', '申请人', '领取用户数', '观看课程用户数']].sort_values(by='领取用户数', ascending=False).reset_index(drop=True)    result_df = pd.DataFrame(index=['TOP1','TOP前10'],columns=['领取用户数','观看课程用户数','领取占比整体','观看占比整体'])    printInfo('数据输出：前10名企业领取情况',data.head(10))    #获取头部用户占比情况    set_course_count_value(result_df,data,'TOP1',1)    set_course_count_value(result_df,data,'TOP前10',10)    set_course_count_value(result_df,data,'TOP前30',30)    printInfo('数据输出：头部用户占比',result_df)    return result_df#2.每日新增领取公司倒序排列（数量和人数与当日新增匹配）def day_increase_data(yesterday_df,last_last_day_df):    #合并昨天和前天数据    temp_df = pd.merge(yesterday_df,last_last_day_df,on='已申请的公司',how='left')    yesterday_df['日新增领取用户数'] = temp_df['领取用户数_x'] - temp_df['领取用户数_y']    yesterday_df['日新增观看课程用户数'] = temp_df['观看课程用户数_x'] - temp_df['观看课程用户数_y']    #按照新增领取用户数倒叙排列    yesterday_df = yesterday_df.sort_values(by='日新增领取用户数',ascending=False).reset_index(drop=True)    #过滤掉没有新增的企业    yesterday_df = yesterday_df[yesterday_df['日新增领取用户数']>0]    result_df = yesterday_df[['已申请的公司','归属分社','日新增领取用户数','日新增观看课程用户数']]    printInfo('数据输出：企业日新增',result_df.head(15))    printInfo('昨日累计新增数据',result_df[['日新增领取用户数','日新增观看课程用户数']].sum())#1.平均值：领取用户，看课，观看转化率，学习观看时长，企业平均看课人数def community_mean_data(df):    grouped = df.groupby(by='归属分社')[['领取用户数', '观看课程用户数', '观看转化率', '平均学习时长（秒）']].agg({        '领取用户数': np.sum,        '观看课程用户数': np.sum,        '观看转化率': np.mean,        '平均学习时长（秒）': np.mean    }).sort_values(by='领取用户数', ascending=False)    #添加企业平均看课人数计算    grouped['已领取企业平均领取用户数'] = grouped['领取用户数'] / df[df['领取用户数']>0].groupby(by='归属分社')['已申请的公司'].size()    grouped['已申请企业平均领取用户数'] = grouped['领取用户数'] / df.groupby(by='归属分社')['已申请的公司'].size()    #插入'归属分社'一列    grouped.insert(0, '归属分社', grouped.index)    #重置index    result_df = grouped.reset_index(drop=True)    #过滤掉领取数为0的分社，多数为虚拟分社    result_df = result_df[result_df['领取用户数']>0]    printInfo ('数据输出：不同分社基础数据',result_df)    return result_df#2.每个分社头部3个企业：分别是是谁def community_top_data(df):    print ('community_top_data')    top_num = 5 #top名词    title = '领取用户数'#对应字段    grouped = df.groupby(by='归属分社').apply(lambda x: x.sort_values(by=title,ascending=False).reset_index(drop=True)[0:top_num][title].sum())    #构建df    top_columns_name = 'top'+title    top_sum_df = pd.DataFrame(grouped,columns=[top_columns_name])    # printInfo ('分社划分之后，领取用户数倒叙',top_sum_df)    #计算总和    sum_df = df.groupby(by='归属分社').agg({title:np.sum}).reset_index()    #合并top和总和，计算top占比总和    result_df = pd.merge(sum_df,top_sum_df,on='归属分社')    result_df['top占比'] = result_df[top_columns_name] / result_df[title]    result_df = result_df.sort_values(by=[title,'top占比'],ascending=False).reset_index(drop=True)    # printInfo('计算每个分社头部的和',sum_df)    print_str = '数据输出：Top'+str(top_num)+'的'+title+'占比整体比例'    printInfo(print_str,result_df)def cut_data(x):    bins = [0,1,50,100,500,1000,5000,10000]    label = ['0','1~50','50~100','100~500','500~1000','1000~5000','5000~10000']    x = x.sort_values(by='领取用户数',ascending=False).reset_index(drop=True)    x['领取用户区间'] = pd.cut(x['领取用户数'],bins,labels=label,include_lowest=True)    #返回领取人数区间分布    return x['领取用户区间'].value_counts()#3.企业领取用户数区间分布def community_distribute_data(df):    grouped = df.groupby(by='归属分社').apply(cut_data)    printInfo ('数据输出：分社企业领取人数分布',grouped.unstack())#获取企业信息def initCompanyInfo(yesterday_df):    PROJECT_ROOT = os.path.dirname(os.path.realpath(__file__))    path = os.path.join(PROJECT_ROOT,'data/一亿赠课企业信息.xlsx')    company_info_df = pd.read_excel(path)    result_df_1 = pd.pivot_table(company_info_df,index=['所属分社ID','申请人职位'],values=['课包领取量'],aggfunc=[np.sum],margins=True,margins_name='课包领取量')    printInfo('企业信息-领取课程数量',result_df_1)    printInfo('企业信息-企业类型分布',company_info_df['企业类型'].value_counts())'''整体：1.头部TOP10企业领取，看课数量，占比整体百分比，分社归属分布2.每日新增领取公司倒序排列（数量和人数与当日新增匹配）分社维度划分，1.平均值：领取用户，看课，观看转化率，学习观看时长，企业平均看课人数2.每个分社头部3个企业：分别是谁，领取用户，看课人数 占比整体情况3.企业领取用户数区间分布4.现有已建立上联系企业的信息分布情况'''def init():    yesterday = (date.today() + timedelta(days=-1)).strftime("%Y-%m-%d")  # 昨天日期    yesterday_df = initData(yesterday)    get_course_count(yesterday_df)    community_mean_data(yesterday_df)    #计算累计新增公司    last_last_day =  (date.today() + timedelta(days=-2)).strftime("%Y-%m-%d") #前天日期    last_last_day_df = initData(last_last_day)    day_increase_data(yesterday_df,last_last_day_df)    community_top_data(yesterday_df)    community_distribute_data(yesterday_df)    #获取公司信息数据    initCompanyInfo(yesterday_df)if __name__ == '__main__':    # 让中文显示正常    plt.rcParams['font.sans-serif'] = ['Microsoft YaHei']  # 用来正常显示中文标签字体。Microsoft YaHei 或 SimHei    plt.rcParams['axes.unicode_minus'] = False  # 用来正常显示负号    init()