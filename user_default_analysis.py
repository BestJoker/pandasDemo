# coding:utf-8import pandas as pdimport numpy as npimport osimport matplotlib.pyplot as pltimport seaborn as snsimport datetimeimport randomimport pandas_profilingpd.options.mode.chained_assignment = None # 默认是'warn'plt.rcParams['font.sans-serif']=['Microsoft YaHei'] #用来正常显示中文标签字体。Microsoft YaHei 或 SimHeiplt.rcParams['axes.unicode_minus']=False #用来正常显示负号'''3. 项目目的：根据客户信息，建立违约模型，利用AUC和KS值作为评价指标，最终选出评价效果最好的预测模型。'''#获取文件地址def get_file_path(file_name):    PROJECT_ROOT = os.path.dirname(os.path.realpath(__file__))    path = os.path.join(PROJECT_ROOT, 'data/user-default-data/'+file_name)    return path#获取原始数据,return 数据+是否处理后def get_handle_data():    handle_path = get_file_path('user-default-handle-data.csv')    try:        handle_df = pd.read_csv(handle_path)    except IOError:        print('没有处理过的数据，读取原始数据')        path = get_file_path('cs-training.csv')        orign_df = pd.read_csv(path)        watch_data(orign_df)        handle_df = handle_data(orign_df)        return handle_df    else:        print ('数据已经处理过，直接读取')        handle_df = pd.read_csv(handle_path)        return handle_df#处理数据def watch_data(orign_df):    #1.处理count异常值    df = orign_df.copy()    print (df.info())    print (df.describe().T)    ########## 探索中发现的问题 ##########    # 1.数据共150000条记录，检查ID是否重复    print (df.shape[0]-df["Unnamed: 0"].nunique())  #无重复ID    # 2.检查是否有重复的变量名    print (len(df.columns) - df.columns.nunique()) #无重复变量名    # 3.变量DebtRatio 存在异常值    DebtRatio_num = df.loc[df['DebtRatio']>1,'DebtRatio'].shape[0]    DebtRatio_per = df.loc[df['DebtRatio'] > 1,'DebtRatio'].shape[0] / df[        "Unnamed: 0"].nunique()    print('DebtRatio的异常值共 {} 个'.format(DebtRatio_num))    print('DebtRatio的异常值占比 {}% '.format(round(DebtRatio_per, 2) * 100))    # 4.MonthlyIncome 上分位数是8249，最大值是3008750，说明可能存在异常值异常值    # f, ax = plt.subplots(figsize=(10, 5))    # sns.distplot(df['MonthlyIncome'])    # ax.set_title('Distribution of MonthlyIncome')    # plt.show()    # 结论：月收入主要集中在500000以内，还需要统计大于500000的数量    print ((df['MonthlyIncome']>500000).sum())    # 输出：12    # 结果：超过500000只有12个，这几个ID的收入可能是异常值，可用500000代替原有的值(仍然是高收入，并不会影响实际含义)    # 生成报告    # report = pandas_profiling.ProfileReport(df)    # print (report)    # report.to_file("output_file.html")def handle_data(orign_df):    #1.处理count异常值    df = orign_df.copy()    #1.剔除age=0的样本    df = df.drop(index=df[df['age'] == 0].index, axis=0)    # 2.将MonthlyIncome中大于500000的值替换为500000    df.loc[df['MonthlyIncome']>500000,'MonthlyIncome'] = 500000    # 3.填补MonthlyIncome的缺失值    # 探究收入和违约率之间的关系    # 收入低于0.25分位数的违约率    bad_rate_25 = (df.loc[df['MonthlyIncome']<df['MonthlyIncome'].describe()['25%'],'SeriousDlqin2yrs']).mean()    bad_rate_75 = (df.loc[df['MonthlyIncome']>df['MonthlyIncome'].describe()['75%'],'SeriousDlqin2yrs']).mean()    bad_rate_25_75 = (df.loc[(df['MonthlyIncome']>=df['MonthlyIncome'].describe()['25%']) & (df['MonthlyIncome']<=df['MonthlyIncome'].describe()['75%']),'SeriousDlqin2yrs']).mean()    print('收入低于0.25分位数的违约率是{}'.format(round(bad_rate_25, 2)))    print('收入位于0.25和0.75分位数之间的违约率是{}'.format(round(bad_rate_25_75, 2)))    print('收入超过0.75分位数的违约率是{}'.format(round(bad_rate_75, 2)))    # 结论：收入越高，违约率越低，收入缺失值的填充对模型有很大影响，需要找到和收入相关的变量，保证填充的合理性    #年龄与收入之间的关系    plt.figure(figsize=(15,5))    sns.relplot(x='age',y='MonthlyIncome',data=df)    plt.ylim([0,100000])    plt.show()    # 因为收入越低，违约率越高，为了尽可能识别出高违约率客户，使用较低的收入填充    # 年龄段不同，收入不同，用每个年龄段的0.05分位数填充对应年龄段的收入    MonthlyIncome_20_40 = df.loc[df['age']<=40,'MonthlyIncome'].describe(percentiles=[0.05])['5%']    MonthlyIncome_40_60 = df.loc[(df['age']>40) & (df['age']<=60),'MonthlyIncome'].describe(percentiles=[0.05])[5%]    MonthlyIncome_60 = df.loc[df['age']>60,'MonthlyIncome'].describe(percentiles=[0.05])['5%']    if __name__ == '__main__':    handle_df = get_handle_data()