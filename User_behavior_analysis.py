# coding:utf-8import pandas as pdimport numpy as npimport osimport matplotlib.pyplot as pltimport seaborn as snsimport datetimepd.options.mode.chained_assignment = None # 默认是'warn'plt.rcParams['font.sans-serif']=['Microsoft YaHei'] #用来正常显示中文标签字体。Microsoft YaHei 或 SimHeiplt.rcParams['axes.unicode_minus']=False #用来正常显示负号#获取原始数据,return 数据+是否处理后def get_orign_data():    #处理后数据    PROJECT_ROOT = os.path.dirname(os.path.realpath(__file__))    handle_path = os.path.join(PROJECT_ROOT, 'data/behavior_handled.txt')    # 如果有已经处理好的数据，那就直接读取，如果没有，则读取原始数据进行处理    try:        handle_df = pd.read_csv(handle_path, sep='\t')    except IOError:        print('没有处理过的数据，读取原始数据')        path = os.path.join(PROJECT_ROOT, 'data/behavior.txt')        # 我使用txt文件是以tab键分隔的，故sep=‘\t’        orign_df = pd.read_csv(path, sep='\t')        print (orign_df.info())        return orign_df,False    else:        print ('数据已经处理过，直接读取')        handle_df = pd.read_csv(handle_path, sep='\t')        return handle_df,True#处理元数据def handle_data(df):    #保留一份原始数据    temp_df = df.copy()    #1.观察数据    print (temp_df.head())    #2.检查是否有重复数据 - 没有    print (temp_df.duplicated().value_counts())    #3.处理时间，转化为访问网站的具体时间，月份，日期，每天几点    temp_df['time1'] = temp_df['time'].apply(lambda x:datetime.datetime.fromtimestamp(x))    temp_df['month'] = temp_df['time'].apply(lambda x: int(datetime.datetime.fromtimestamp(x).strftime('%Y%m')))    temp_df['date'] = temp_df['time'].apply(lambda x: datetime.datetime.fromtimestamp(x).strftime('%Y%m%d'))    temp_df['hour'] = temp_df['time1'].apply(lambda x:x.hour)    #4.销售金额计算    temp_df['money'] = temp_df['price']*temp_df['amount']    #5.缺失值处理：观看有没有缺失值    print (temp_df.isnull().sum())    #6.观察数据有没有异常值    print (temp_df.describe())    PROJECT_ROOT = os.path.dirname(os.path.realpath(__file__))    handle_path = os.path.join(PROJECT_ROOT, 'data/behavior_handled.txt')    temp_df.to_csv(handle_path, sep='\t', index=False)    print ('成功保存处理完数据')    return temp_df'''三、用户行为分析：pv/uv'''# 1.pv/uv 按天分析，观察其访问走势def behavior_analysis_1(df):    temp_df = df.copy()    pv_df = temp_df[temp_df['behavior']=='pv']['date'].value_counts().to_frame(name='pv')    uv_df = temp_df[['user_id','date']].drop_duplicates()['date'].value_counts().to_frame(name='uv')    result_df = pd.merge(pv_df,uv_df,left_index=True,right_index=True).sort_index(ascending=True)    result_df['avg_pv'] = result_df['pv'] / result_df['uv']    result_df.index.name = 'date'    result_df.index = result_df.index.astype(str)    print (result_df)    fig,axes = plt.subplots(1,3,figsize=(18,3))    color_array = ['blue','green','red']    for i in range(len(result_df.columns)):        column = result_df.columns[i]        axes[i].plot(result_df.index,result_df[column],color=color_array[i],marker='o')        axes[i].set_title(column)    plt.show()# 2.pv/uv 按天分析,观察每个行为操作的点击量def behavior_analysis_2(df):    temp_df = df.copy()    pv = pd.pivot_table(temp_df,index=['date'],columns=['behavior'],values='user_id',aggfunc='count')    pv.plot(kind='bar',stacked=True)    plt.show()    pv['all'] = pv.sum(axis=1)    print (pv)# 3.观察用户每天访问高峰时段def behavior_analysis_3(df):    temp_df = df.copy()    result_df = temp_df['hour'].value_counts().to_frame()    plt.bar(result_df.index,result_df['hour'],color='b')    plt.show()'''四、获客分析'''# 4.观察每日新增用户情况，新用户定义，第一次访问网站def behavior_analysis_4(df):    temp_df = df.copy()    result_df = temp_df[['user_id','date']].groupby(by='user_id').min()['date'].value_counts().reset_index().rename(columns={'index':'date','date':'uv'})    result_df['date'] = result_df['date'].astype(str)    plt.plot(result_df['date'],result_df['uv'])    plt.xlabel('日期',fontsize=12)    plt.ylabel('人数',fontsize=12)    plt.title('每日新增用户数',fontsize=16)    plt.show()    print (result_df)'''五.用户留存分析留存定义为1月1日，新增用户200人。次日留存：第二天，1月2日，这200人里面有100人活跃，则次日留存率为100/200=50%2日留存：第三天，1月3日，这200人里面有80人活跃，则2日留存率为80/200=40%，以此类推。'''#建立n日留存率计算函数，data传入用户id和登录日期，start_date为起始时间(格式为：%Y%m%d)，n为n日留存，不传入start_date和n时，则计算所有留存def cal_retention(data,start_date='20100101',n=0):    if n > 0:        #筛选出用户第一天访问的记录        new_user = data[['user_id','date']].groupby('user_id').min().reset_index()        print (new_user.head())        #根据n和其实日期 计算出n日留存的结束日期        date2 = datetime.datetime.strptime(start_date,'%Y%m%d')+datetime.timedelta(n)        end_date = datetime.datetime.strftime(date2,'%Y%m%d')        print (end_date)        #计算出开始日期的用户        start_user = set(new_user[new_user['date']==start_date].user_id)        #计算出结束日期的用户        end_user = set(data[data['date']==end_date].user_id)        #取两个集合的交集        user = start_user&end_user        print ('{}的新用户为{}，在第{}天用户为{}，留存率为{}'.format(start_date,len(start_user),n,len(user),round(len(user)/len(start_user),4)))        return [start_date,n,end_date,len(start_user),len(user),round(len(user)/len(start_user),4)]    else:        #筛选出用户第一天访问的记录        new_user = data[['user_id','date']].groupby('user_id').min().reset_index()        date_sourse = new_user.date.unique()        date_sourse.sort()        print (date_sourse)        result=[]        flag=0        for start_date in date_sourse:            # 计算出开始日期的用户            start_user = set(new_user[new_user['date'] == start_date].user_id)            for end_date in date_sourse[flag:]:                end_user = set(data[data['date']==end_date].user_id)                user = start_user&end_user                result.append([start_date,end_date,len(start_user),len(user),round(len(user)/len(start_user),4)])            flag = flag + 1        return pd.DataFrame(result,columns=['开始日期','留存日期','新用户数','留存人数','留存率'])#留存分析def behavior_analysis_5(df):    temp_df = df.copy()    result_df = cal_retention(temp_df[['user_id','date']])    print (result_df)    #获取留存人数    df1 = pd.pivot_table(result_df,index=['开始日期'],columns=['留存日期'],values=['留存人数'],aggfunc='sum',fill_value=0)    print (df1)    #获取留存率    df2 = pd.pivot_table(result_df,index=['开始日期'],columns=['留存日期'],values=['留存率'],aggfunc='sum',fill_value=0)    print (df2)    sns.heatmap(df2,annot=True,fmt='.2f',linewidths=.5)    plt.show()'''六.复购分析指在单位时间内，重复购买率=再次购买人数/总购买人数例如在一个月内，有100个用户成交，其中20个是回头客，则重复购买率为20%此处的回头客定义为：按天去重，即一个客户一天内产生多笔交易付款则算一次购买，除非在统计周期内另外一天也有购买的客户才算是回头客'''def behavior_analysis_6(df):    temp_df = df.copy()    date_buy = temp_df[temp_df['behavior']=='buy'][['user_id','date']].drop_duplicates()['user_id'].value_counts().reset_index()    date_buy.columns = ['user_id','num']    rebuy_rate = round(len(date_buy[date_buy['num']>=2]) / len(date_buy),4)    print (rebuy_rate)    num_df = date_buy['num'].value_counts().reset_index()    num_df.columns = ['购买次数','购买人数']    num_df['人数占比'] = round(num_df['购买人数'] / len(date_buy),4)    print (num_df)    fig = plt.figure(figsize=(10,5),dpi=80)    plt.bar(num_df['购买次数'],num_df['购买人数'],color='b')    plt.show()'''七.RFM模型分析RFM模型分析前提条件：a.最近有过交易行为的客户，再次发生交易的可能性高于最近没有交易行为的客户b.交易频率较高的客户比交易频率较低的客户，更有可能再次发生交易行为c.过去所有交易金额较多的客户，比交易金额较少的客户，更有消费积极性'''#获取对应的RFM模型def get_RFM(df):    #取数规则：最近一次消费的时间取最大，消费频次根据计数统计，消费金额求平均值统计    RFM_date = df[df['behavior']=='buy'][['user_id','date']].groupby(by='user_id').max()    print (RFM_date)    RFM_F = df[df['behavior']=='buy'][['user_id','behavior']].groupby(by='user_id').count()    print (RFM_F)    RFM_M = df[df['behavior']=='buy'][['user_id','money']].groupby(by='user_id').mean()    print (RFM_M)    RFM=RFM_date.join(RFM_F).join(RFM_M)    print (RFM)    #用户价值分层（RFM模型）：模型计算日期为2019-12-05    end_date = datetime.datetime.strptime('20191205','%Y%m%d')    #时间间隔天数计算    RFM['days'] = RFM['date'].apply(lambda x:(end_date-datetime.datetime.strptime(x,'%Y%m%d')).days)    RFM = RFM[['days','behavior','money']]    RFM.columns=['间隔天数','消费频次','消费金额']    return RFM#根据最近一次交易时间间隔计算得分def recency(x):    if x<=2:        return 5    elif x==3:        return 4    elif x==4:        return 3    elif x==5:        return 2    elif x>=6:        return 1#根据消费次数计算得分def frequency(x):    if x>=8:        return 5    elif x>=6:        return 4    elif x>=4:        return 3    elif x>=2:        return 2    elif x>=0:        return 1#根据消费金额计算得分def monetary(x):    if x>=300:        return 5    elif x>=200:        return 4    elif x>=100:        return 3    elif x>=50:        return 2    elif x>=0:        return 1def behavior_analysis_7(df):    temp_df = df.copy()    #获取RFM模型    RFM = get_RFM(temp_df)    print (RFM)    RFM['R_S'] = RFM['间隔天数'].apply(recency)    RFM['F_S'] = RFM['消费频次'].apply(frequency)    RFM['M_S'] = RFM['消费金额'].apply(monetary)    RFM['RFM'] = RFM.apply(lambda x:int(x.R_S*100+x.F_S*10+x.M_S),axis=1)    print (RFM.head(5))    #每一个RFM代码都对应一小组客户'''九.商品销售分析'''#商品top分析def behavior_analysis_8(df):    temp_df = df.copy()    fig = plt.figure(figsize=(25,15),dpi=80)    #销售次数前10    buy_top = temp_df[temp_df['behavior']=='buy']['goods_id'].value_counts().head(10).reset_index()    buy_top.columns = ['goods_id','counts']    print (buy_top)    ax0 = plt.subplot(2,2,1)    ax0.set_title('销售次数前10商品')    ax0.bar(buy_top['goods_id'].astype(str),buy_top['counts'],color='b')    #浏览次数前10    pv_top = temp_df[temp_df['behavior']=='pv']['goods_id'].value_counts().reset_index().head(10)    pv_top.columns = ['goods_id','pv']    print (pv_top)    ax1 = plt.subplot(2,2,2)    ax1.set_title('销售次数前10商品')    ax1.bar(pv_top['goods_id'].astype(str),pv_top.pv,color='r')    #城市购买力    city_buy_top = temp_df[temp_df['behavior']=='buy']['addr'].value_counts().reset_index()    city_buy_top.columns = ['addr','counts']    print (city_buy_top)    ax2 = plt.subplot(2,1,2)    ax2.set_title('销售次数前10商品')    ax2.bar(city_buy_top.addr,city_buy_top.counts,color='g')    plt.show()if __name__ == '__main__':    data_df,handled = get_orign_data()    #如果是未处理过的，则进行数据处理    if handled == False:        data_df = handle_data(data_df)    print (data_df.info())    #将日期转为字符串    data_df['date'] = data_df['date'].astype(str)    behavior_analysis_8(data_df)