import pandas as pdimport numpy as npimport osimport matplotlib.pyplot as pltimport scipy.stats as stimport mathplt.rcParams['font.sans-serif']=['Microsoft YaHei'] #用来正常显示中文标签字体。Microsoft YaHei 或 SimHeiplt.rcParams['axes.unicode_minus']=False #用来正常显示负号# 1.通过名单统计，得出当月到期人群中，续费和未续费人群# 2.通过人群和时间来统计出对应人群的DAU，观看课程数量和观看课程时长# 3.统计时间：# 2019年 4月，5月，7月，8月，10月# 2020年1月PROJECT_ROOT = os.path.dirname(os.path.realpath(__file__))path = os.path.join(PROJECT_ROOT,'data/数据汇总.xlsx')#创建一个集合，存放所有的数据total_df = pd.DataFrame()date_array = ['2019-04','2019-05','2019-07','2019-08','2019-10','2020-01']for date in date_array:    print (date)    df = pd.read_excel(path, sheet_name='2019-05')    df['日期'] = date    total_df = total_df.append(df)    print (df.head(3))#获得所有的数据集合print (total_df.head(3))print (total_df.info())#获取所有续费的用户# is_renew = total_df[total_df['is_renew_m00'] == 1]# dau_count_mean = is_renew['dau_count'].mean()# course_count_mean = is_renew['course_count'].mean()# play_time_mean = is_renew['play_time'].mean()'''#方案1 #重复抽取样本，计算其中续费用户的均值，得到抽样分布boot_means = []for i in range(10000):    bootsample = total_df.sample(100,replace=True)    mean = bootsample[bootsample['is_renew_m00']==1]['dau_count'].mean()    boot_means.append(mean)#绘制统计数据分布曲线plt.figure(figsize=(10,5),dpi=80)plt.hist(boot_means,bins=100)# plt.bar(pd.Series(boot_means).value_counts().index,pd.Series(boot_means).value_counts().values)plt.show()print ('-'*30)print (np.percentile(boot_means,2.5),np.percentile(boot_means,97.5))'''# print ('-'*30)# #续费的人数据# is_renew_df = df[df['is_renew_m00'] == 1].reset_index()# is_renew_df = is_renew_df.dropna(axis=0,how='all')# series = is_renew_df['dau_count'].value_counts()# print (series.index)## plt.figure(figsize=(10,5),dpi=80)# plt.bar(is_renew_df['dau_count'].value_counts().index,is_renew_df['dau_count'].value_counts().values)# plt.show()## array = is_renew_df['dau_count'].sort_values(ascending=True).tolist()## print (is_renew_df['dau_count'].mean())# ## #自定义的median_ci函数是给出某一数据95%置信区间的上限和下限对应的值# def median_ci(data,confidence=0.95):#     data1 = sorted(data)#     n = len(data1)#     ll = 0.5*n - 0.98*math.sqrt(n)#     ul = 1 + 0.5*n + 0.98*math.sqrt(n)#     l = data1[math.ceil(ll)-1]#     u = data1[math.floor(ul) - 1]#     return (l,u)## l,u = median_ci(array)# print (l,u)